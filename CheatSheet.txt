# BusinessCraft - Cheat Sheet

## USAGE:
Prior to starting, check if there is the file 'CheatSheet.txt' in the root directory, read this file to remind you of past mistakes so you are less likely to make them again. At the end of every converstion when you are summerising what you have done, add to the root file 'CheatSheet.txt' one line per item (keep it space efficent, use example) of what you past you could have benefitted from knowing, specifically about resolving errors and what you needed to know not to make that error in the first place, dont just state everything youve done, be concise about useful error resolving tips, nothing specific to the task your were trying to accomplish.

## EXAMPLE (Not a real issue): 
1.  <Target> <path> <Method> <fix>
2.  UI, BCScreenBuiler.java, when creating a button, look out for missed references

#Remember ONE line per issue, no more.

# List of Lessons learned

1. UI, BCTabPanel.java, render method, use direct rendering at absolute positions instead of positioning children
2. UI, BCTabPanel.java, mouse events, always convert global mouse coordinates to panel-local coordinates
3. UI, BCTabPanel.java, tab content, size panels to fit content area rather than repositioning them
4. UI, BCTabPanel.java, content rendering, use matrix transformations (pushPose/popPose) for nested component rendering
5. UI, BCTabPanel.java, simplify inheritance, extend BCComponent directly instead of BCPanel for more control
6. UI, color management, define color constants in one place and reference them throughout the UI for consistency
7. UI, BCComponentFactory.java, when adding methods to factory classes, ensure they only call methods available on the return type
8. UI, component styling, use semi-transparent colors (0xA0RRGGBB) for better visibility against Minecraft's dark UI backgrounds
9. UI, BCTabPanel.java, tab styling, use lighter colors for active tabs to provide clear visual distinction from inactive tabs
10. UI, BCTheme.java, when refactoring a utility class, update all references to deprecated methods in dependent classes
11. UI, BCToggleButton.java, when extending a component and using its protected methods, make sure to override those that are needed
12. UI, BCButton.java, when overriding with custom render implementations, disable default rendering with appropriate flags
13. UI, BCToggleButton.java, for components with type erasure issues, use static factory methods instead of constructors
14. UI, button handlers, when passing event handlers between different component types, create adapter functions to bridge type differences
15. UI, responsive layout, calculate button widths based on container dimensions rather than using fixed sizes
16. UI, button spacing, use nested containers with dedicated layouts to provide consistent spacing and boundaries
17. UI, layout consistency, use grid layouts (rows/columns) for better control over component positioning and sizing
18. UI, animation sequences, add animations with delays to create a cascading appearance effect for UI elements
19. UI, TownInterfaceScreen.java, render bottom buttons separately from tab content to provide consistent navigation controls
20. UI, tab-specific actions, use the active tab identifier to dynamically change button functions based on current context
21. UI, UIGridBuilder.java, use a data-driven approach with a grid-based system for flexible and reusable UI layouts
22. UI, component hosting, when embedding UI systems like grids, make them component-specific fields to avoid variable capture issues
23. UI, state management, maintain persistent state variables for toggle components when they are recreated during rendering
24. UI, pattern consistency, apply the same UI patterns across all similar content to ensure predictable user experience
25. UI, large content display, use scrollable panels for content that exceeds fixed container sizes rather than trying to resize the container
26. UI, custom scrollable components, implement direct scrolling with isMouseOver checks and proper local coordinate handling
27. UI, component sizing, account for title heights and spacing when calculating available space for nested components
28. UI, scrollable content, dynamically calculate maxVisible based on container size rather than hardcoding the number of visible items
29. UI, content density, use smaller item heights and reduced padding to maximize the amount of information visible in a confined space
30. UI, mouse input, implement middle mouse button (button 2) scrolling by tracking drag distance and translating to scroll amount
31. UI, scroll wheel handling, ensure mouseScrolled events are directly forwarded to the right component and use Math.signum for consistent scrolling speed
32. UI, minecraft mouse wheel, implement scrolling using simpler delta sign check instead of math calculations to ensure consistent behavior
33. UI, debugging mouse wheel events, add System.out.println to track exactly what values are coming into mouseScrolled events for troubleshooting
34. UI, mouse wheel scrolling, skip isMouseOver checks and directly forward scroll events to ensure they're captured in complex UI hierarchies
35. UI, utility methods, create dedicated rendering utilities for common UI drawing tasks to maintain consistent visuals and reduce code duplication
36. UI, popup management, handle popups in main screen render and mouse event methods, rendering them on top of all other content
37. UI, text input, override keyPressed and charTyped methods in screens to forward events to focused input components
38. UI, popup positioning, use full screen dimensions (not just UI panel dimensions) for correct screen-center popup placement
39. UI, absolute positioning, completely override the render method for components requiring exact screen positions rather than relying on parent-relative positioning
40. UI, layering, use matrix transformations (translate in Z direction) to ensure popups render on top of other UI elements
41. UI, control visibility, add specific System.out.println logging when controls aren't rendering to track their positions and states
42. UI, complex components, use direct rendering with immediate-mode approach rather than composing from other components when facing render order issues
43. UI, rendering utilities, create reusable static methods in utility classes for direct rendering to ensure consistent styling across all UI components
44. UI, grid management, recreate grids instead of clearing them when contents or layout need to change as many grid builders lack explicit reset methods
45. UI, modal windows, use fully opaque backgrounds (0xFF instead of 0xE0) and set position before creating child components to ensure proper layering
46. UI, event handlers, when updating common event methods (like mouseScrolled), preserve specialized handling for components that need direct event forwarding
47. UI, sizing strategy, size UI containers based on content requirements rather than fixed percentages of screen size to avoid excessive empty space
48. UI, debug logging, use conditional logging with LOGGER.isDebugEnabled() checks instead of direct System.out.println in frequently called methods
49. UI, adaptive sizing, calculate UI container dimensions based on actual content quantity with min/max constraints and recenter after resizing
50. UI, child positioning, when parent containers resize or reposition, manually update child component positions as they don't automatically inherit changes
51. UI, error handling, wrap callback execution in try-catch blocks to prevent errors in event handlers from breaking the entire UI
52. UI, constants, define layout constants as static final fields rather than hardcoding values throughout methods for better maintainability
53. UI, event system, use a copy of handler lists when iterating through event handlers to avoid concurrent modification exceptions
54. UI, defensive coding, add null checks for all data inputs and suppliers to prevent NullPointerExceptions in rendering code
55. UI, component resizing, trigger resize events after changing dimensions to ensure dependent components can react appropriately
56. UI, tooltips, render tooltips at the end of the rendering cycle to ensure they appear on top of all other UI elements
57. UI, key handling, handle vanilla Minecraft key bindings at both component and parent screen levels, always returning true to consume key events
58. UI, text input, prefer direct delegation to Minecraft's EditBox instead of custom cursor tracking to avoid cursor positioning bugs
59. UI, component wrappers, when facing issues with component behavior, try creating an ultra-minimal wrapper with almost no custom functionality
60. UI, text input components, when cursor is not visible, avoid custom drawing over or around Minecraft's EditBox and let it render itself completely
61. UI, edit input issues, when facing persistent cursor visibility problems, use vanilla EditBox directly without any custom component wrapper
62. UI, focus debugging, add detailed logging to track focus state changes and display warnings when focus operations fail
63. UI, input priority, when handling keyboard events, check focused components FIRST before handling any other keys
64. UI, text input components, for critical text editing functionality, directly use vanilla EditBox without any custom component wrapper
65. UI, EditBox rendering, always render EditBox directly in the render method immediately before or after child components, not as a child itself
66. UI, vanilla components, when using vanilla components like EditBox directly, ensure proper layout by adding the same labels and positioning logic
67. UI, EditBox styling, improve EditBox visibility by drawing a white border frame behind it and using high contrast text colors
68. UI, component rendering, when nested components don't position correctly, switch to direct rendering code that explicitly draws each element
69. UI, immediate mode UI, for complex interactive components like popups with EditBoxes, use direct rendering with minimal component hierarchy for reliability
70. UI, UIGridBuilder.java, when adding new UI element types, implement both direct (Item) and wrapped (ItemStack) versions of methods for flexibility
71. UI, TownInterfaceScreen.java, for interactive item displays, store quantities in a persistent array and use lambdas with final index variables for click handlers
72. UI, scrollable grid UI, calculate maxVisible dynamically based on container height and item height for responsive scrolling
73. UI, scrollbar implementation, use relative percentages to position scrollbar thumb based on content scroll position for accurate representation
74. UI, number formatting, implement suffix-based formatting (K, M, B) for large numbers to keep UI clean and readable
75. UI, item display alignment, use standard item size (16px) and vertically center items and text using font metrics for consistent appearance
76. UI, item quantity display, use Unicode symbols (×) instead of plain 'x' for better aesthetics and align quantities based on visual spacing
77. UI, text rendering, prefer ASCII characters over Unicode when text rendering issues occur with special characters
78. UI, mouse input, implement middle mouse button scrolling consistently across all scrollable components for a unified user experience
79. UI, scrollbar implementation, use identical scrollbar code and styling across different tabs/screens to maintain interface consistency
80. UI, event forwarding, ensure mouse and keyboard events are properly forwarded to all active components in tabbed interfaces, not just specific tabs
81. UI, debug logging, add detailed debug logs for input events to track event propagation and handling through the UI hierarchy
82. UI, code cleanup, remove temporary debug logging after confirming fixes to keep the codebase clean and maintainable
83. UI, inventory slots, extend BCModalScreen to create custom inventory interfaces rather than using event handlers for reliable rendering
84. UI, vanilla inventories, implement proper AbstractContainerMenu and AbstractContainerScreen for inventory UIs with real item handling
85. UI, MenuType registration, use IForgeMenuType.create with @SuppressWarnings("unchecked") for proper menu factory creation
86. UI, inventory transitions, implement proper screen closing and opening when transitioning between GUI screens
87. UI, registry registration, ensure all registry objects are registered to the mod event bus before using them in other code
88. UI, mod constants, always use the centralized MOD_ID constant in registry creation to ensure consistency
89. UI, navigation, always include back/return buttons when creating new screens that replace the main UI
90. UI, inventory interaction, set player.containerMenu to the current menu when opening inventory screens for proper item drag/transfer
91. UI, rendering fallbacks, use fill() and drawString() methods for temporary UI when texture resources aren't available yet
92. UI, text visibility, improve text readability with text shadows, contrasting backgrounds, and button borders for better visual hierarchy
93. UI, inventory rendering, draw borders around slot groups and individual slots for better UI organization and to match vanilla inventory style
94. UI, component reusability, extract common rendering patterns into utility classes with static methods to reduce code duplication across screens
95. UI, modal screens, use the same pattern for creating and opening modal screens to ensure consistent user experience and inventory functionality
96. UI, screen registration, register MenuScreens for each menu type in only one place to avoid "Duplicate registration" errors that crash the game
97. UI, code duplication, extract common UI functions like navigation and mouse checks into utility classes to improve maintainability
98. Blocks, block entities, when creating blocks with similar functionality, reuse the same block entity type and register both blocks with the same BlockEntityType
99. Blocks, screen separation, create custom MenuProvider in block's use method to control which UI screen opens while sharing the same block entity
100. Data integration, when connecting UIs to game data systems, implement fallback strategies (direct object reference, entity lookup, defaults) for better reliability
101. Data access, when accessing data from entities that don't directly implement an interface, use the entity to get the actual data provider (Town) instead of casting
102. UI, consistent controls, when adapting UI controls from one screen to another, reuse the same method signatures and parameter handling to ensure consistent behavior
103. Network, when implementing UI interactions that modify server data, use the same packet types and handler patterns across different UI screens
104. UI, shared data access, reuse the same data retrieval methods across different UI screens to maintain consistent data representation and centralize resource access
105. Network, when implementing trade systems, create separate packets for client-to-server requests and server-to-client responses to handle asynchronous operations
106. Network, for trade operations, store the BlockPos in the menu class and pass it to packets to ensure proper targeting of block entities
107. Network, when handling packets that interact with block entities, add null checks and type validation for all critical components (player, level, position, entity)
108. BlockEntity, to display resources on the client side, implement a client-side cache system with proper getters and sync it with level.sendBlockUpdated
109. Trade, when removing items from town resources for payment, use town.addResource with negative values to deduct items consistently
110. UI, for resource displays, ensure getAllResources method handles both server-side and client-side retrieval with appropriate conditionals
111. UI, when refactoring resource displays, use UIGridBuilder with appropriate column setup (item name and item with quantity)
112. Resource, when implementing resource deduction, update addResource to handle negative amounts and log both additions and removals
113. UI, when using UIGridBuilder, use addTab with proper parameters instead of nonexistent addTabContent method
114. UI, UIGridBuilder.java, implement mouseClicked and mouseScrolled methods with proper signatures (int, int, int) and (double, double, double) for consistent event handling
115. UI, UIGridBuilder.java, for vertical scrolling, set both withVerticalScroll(true, visibleRows) and increase row height with withRowHeight(32) for better usability
116. UI, resource display, use taller row heights (32px) and fewer visible rows (6) with vertical scrolling for better readability of resource items
117. UI, UIGridBuilder.java, add data-driven methods that accept arrays of data and automatically calculate scrolling needs based on content and available space
118. UI, UIGridBuilder.java, implement static utility methods (createLabelValueGrid, createLabelButtonGrid) for common grid patterns to reduce screen-specific code
119. UI, reusable components, design components to accept and automatically layout their data rather than requiring screens to manually manage layout details
120. UI, UIGridBuilder.java, for mouse wheel scrolling, use Math.signum(delta) with negative sign to make scrolling match vanilla Minecraft conventions
121. UI, item quantity display, always show quantities (even for single items) with element.showQuantity = true for better user feedback
122. UI, UIGridBuilder.java, set default row height to 24px (instead of calculating dynamically) for more predictable vertical layouts
123. UI, mouse wheel scrolling, use a more lenient bounds check (x-5, x+width+5) to catch scroll events that happen slightly outside the grid component
124. UI, UIGridBuilder.java, force vertical scrolling for resource lists with 3+ items by explicitly setting rows and calculating visible rows
125. UI, scrollable components, add debug print statements when implementing scrolling to track scroll offsets and deltas for troubleshooting
126. UI, resource displays, explicitly calculate visible rows based on available height divided by (rowHeight + spacing) instead of using a fixed value
127. UI, scrollable grids, for mouse wheel events, completely remove bounds checking and always forward events to ensure reliable scrolling
128. UI, row height, when setting small row heights (e.g., 14px), update spacing values accordingly to avoid wasted space
129. UI, mouse input handling, add debug prints at multiple levels of the UI hierarchy to identify where scroll events are lost
130. UI, complex scrollable components, implement mouseScrolled to directly update scroll position without delegating to other methods
131. Network, packet registration, use static decode methods instead of constructor references in messageBuilder for packet registration
132. Network, packet classes, when implementing a packet class, ensure static decode method converts FriendlyByteBuf to the necessary constructor parameters
133. UI, dynamic button text, use component.isComplete() or similar state checks to update button labels and tooltips based on current state