# BusinessCraft - Cheat Sheet

## USAGE:
Prior to starting, check if there is the file 'CheatSheet.txt' in the root directory, read this file to remind you of past mistakes so you are less likely to make them again. At the end of every converstion when you are summerising what you have done, add to the root file 'CheatSheet.txt' one line per item (keep it space efficent, use example) of what you past you could have benefitted from knowing, specifically about resolving errors and what you needed to know not to make that error in the first place, dont just state everything youve done, be concise about useful error resolving tips, nothing specific to the task your were trying to accomplish.

## EXAMPLE (Not a real issue): 
1.  <Target> <path> <Method> <fix>
2.  UI, BCScreenBuiler.java, when creating a button, look out for missed references

#Remember ONE line per issue, no more.

# List of Lessons learned

1. UI, BCTabPanel.java, render method, use direct rendering at absolute positions instead of positioning children
2. UI, BCTabPanel.java, mouse events, always convert global mouse coordinates to panel-local coordinates
3. UI, BCTabPanel.java, tab content, size panels to fit content area rather than repositioning them
4. UI, BCTabPanel.java, content rendering, use matrix transformations (pushPose/popPose) for nested component rendering
5. UI, BCTabPanel.java, simplify inheritance, extend BCComponent directly instead of BCPanel for more control
6. UI, color management, define color constants in one place and reference them throughout the UI for consistency
7. UI, BCComponentFactory.java, when adding methods to factory classes, ensure they only call methods available on the return type
8. UI, component styling, use semi-transparent colors (0xA0RRGGBB) for better visibility against Minecraft's dark UI backgrounds
9. UI, BCTabPanel.java, tab styling, use lighter colors for active tabs to provide clear visual distinction from inactive tabs
10. UI, BCTheme.java, when refactoring a utility class, update all references to deprecated methods in dependent classes
11. UI, BCToggleButton.java, when extending a component and using its protected methods, make sure to override those that are needed
12. UI, BCButton.java, when overriding with custom render implementations, disable default rendering with appropriate flags
13. UI, BCToggleButton.java, for components with type erasure issues, use static factory methods instead of constructors
14. UI, button handlers, when passing event handlers between different component types, create adapter functions to bridge type differences
15. UI, responsive layout, calculate button widths based on container dimensions rather than using fixed sizes
16. UI, button spacing, use nested containers with dedicated layouts to provide consistent spacing and boundaries
17. UI, layout consistency, use grid layouts (rows/columns) for better control over component positioning and sizing
18. UI, animation sequences, add animations with delays to create a cascading appearance effect for UI elements
19. UI, TownInterfaceScreen.java, render bottom buttons separately from tab content to provide consistent navigation controls
20. UI, tab-specific actions, use the active tab identifier to dynamically change button functions based on current context
21. UI, UIGridBuilder.java, use a data-driven approach with a grid-based system for flexible and reusable UI layouts
22. UI, component hosting, when embedding UI systems like grids, make them component-specific fields to avoid variable capture issues
23. UI, state management, maintain persistent state variables for toggle components when they are recreated during rendering
24. UI, pattern consistency, apply the same UI patterns across all similar content to ensure predictable user experience
25. UI, large content display, use scrollable panels for content that exceeds fixed container sizes rather than trying to resize the container
26. UI, custom scrollable components, implement direct scrolling with isMouseOver checks and proper local coordinate handling
27. UI, component sizing, account for title heights and spacing when calculating available space for nested components
28. UI, scrollable content, dynamically calculate maxVisible based on container size rather than hardcoding the number of visible items
29. UI, content density, use smaller item heights and reduced padding to maximize the amount of information visible in a confined space
30. UI, mouse input, implement middle mouse button (button 2) scrolling by tracking drag distance and translating to scroll amount
31. UI, scroll wheel handling, ensure mouseScrolled events are directly forwarded to the right component and use Math.signum for consistent scrolling speed
32. UI, minecraft mouse wheel, implement scrolling using simpler delta sign check instead of math calculations to ensure consistent behavior
33. UI, debugging mouse wheel events, add System.out.println to track exactly what values are coming into mouseScrolled events for troubleshooting
34. UI, mouse wheel scrolling, skip isMouseOver checks and directly forward scroll events to ensure they're captured in complex UI hierarchies
35. UI, utility methods, create dedicated rendering utilities for common UI drawing tasks to maintain consistent visuals and reduce code duplication
36. UI, popup management, handle popups in main screen render and mouse event methods, rendering them on top of all other content
37. UI, text input, override keyPressed and charTyped methods in screens to forward events to focused input components
38. UI, popup positioning, use full screen dimensions (not just UI panel dimensions) for correct screen-center popup placement
39. UI, absolute positioning, completely override the render method for components requiring exact screen positions rather than relying on parent-relative positioning
40. UI, layering, use matrix transformations (translate in Z direction) to ensure popups render on top of other UI elements
41. UI, control visibility, add specific System.out.println logging when controls aren't rendering to track their positions and states
42. UI, complex components, use direct rendering with immediate-mode approach rather than composing from other components when facing render order issues
43. UI, rendering utilities, create reusable static methods in utility classes for direct rendering to ensure consistent styling across all UI components
