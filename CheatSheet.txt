# BusinessCraft - Cheat Sheet

## USAGE:
Prior to starting, check if there is the file 'CheatSheet.txt' in the root directory, read this file to remind you of past mistakes so you are less likely to make them again. At the end of every converstion when you are summerising what you have done, add to the root file 'CheatSheet.txt' one line per item (keep it space efficent, use example) of what you past you could have benefitted from knowing, specifically about resolving errors and what you needed to know not to make that error in the first place, dont just state everything youve done, be concise about useful error resolving tips, nothing specific to the task your were trying to accomplish.

## EXAMPLE (Not a real issue): 
1.  <Target> <path> <Method> <fix>
2.  UI, BCScreenBuiler.java, when creating a button, look out for missed references

#Remember ONE line per issue, no more.

# List of Lessons learned

1. UI, BCTabPanel.java, render method, use direct rendering at absolute positions instead of positioning children
2. UI, BCTabPanel.java, mouse events, always convert global mouse coordinates to panel-local coordinates
3. UI, BCTabPanel.java, tab content, size panels to fit content area rather than repositioning them
4. UI, BCTabPanel.java, content rendering, use matrix transformations (pushPose/popPose) for nested component rendering
5. UI, BCTabPanel.java, simplify inheritance, extend BCComponent directly instead of BCPanel for more control
6. UI, color management, define color constants in one place and reference them throughout the UI for consistency
7. UI, BCComponentFactory.java, when adding methods to factory classes, ensure they only call methods available on the return type
8. UI, component styling, use semi-transparent colors (0xA0RRGGBB) for better visibility against Minecraft's dark UI backgrounds
9. UI, BCTabPanel.java, tab styling, use lighter colors for active tabs to provide clear visual distinction from inactive tabs
10. UI, BCTheme.java, when refactoring a utility class, update all references to deprecated methods in dependent classes
11. UI, BCToggleButton.java, when extending a component and using its protected methods, make sure to override those that are needed
12. UI, BCButton.java, when overriding with custom render implementations, disable default rendering with appropriate flags
13. UI, BCToggleButton.java, for components with type erasure issues, use static factory methods instead of constructors
14. UI, button handlers, when passing event handlers between different component types, create adapter functions to bridge type differences
15. UI, responsive layout, calculate button widths based on container dimensions rather than using fixed sizes
16. UI, button spacing, use nested containers with dedicated layouts to provide consistent spacing and boundaries
17. UI, layout consistency, use grid layouts (rows/columns) for better control over component positioning and sizing
18. UI, animation sequences, add animations with delays to create a cascading appearance effect for UI elements
19. UI, TownInterfaceScreen.java, render bottom buttons separately from tab content to provide consistent navigation controls
20. UI, tab-specific actions, use the active tab identifier to dynamically change button functions based on current context
21. UI, UIGridBuilder.java, use a data-driven approach with a grid-based system for flexible and reusable UI layouts
22. UI, component hosting, when embedding UI systems like grids, make them component-specific fields to avoid variable capture issues
23. UI, state management, maintain persistent state variables for toggle components when they are recreated during rendering
24. UI, pattern consistency, apply the same UI patterns across all similar content to ensure predictable user experience
25. UI, large content display, use scrollable panels for content that exceeds fixed container sizes rather than trying to resize the container
26. UI, custom scrollable components, implement direct scrolling with isMouseOver checks and proper local coordinate handling
27. UI, component sizing, account for title heights and spacing when calculating available space for nested components
28. UI, scrollable content, dynamically calculate maxVisible based on container size rather than hardcoding the number of visible items
29. UI, content density, use smaller item heights and reduced padding to maximize the amount of information visible in a confined space
30. UI, mouse input, implement middle mouse button (button 2) scrolling by tracking drag distance and translating to scroll amount
31. UI, scroll wheel handling, ensure mouseScrolled events are directly forwarded to the right component and use Math.signum for consistent scrolling speed
32. UI, minecraft mouse wheel, implement scrolling using simpler delta sign check instead of math calculations to ensure consistent behavior
33. UI, debugging mouse wheel events, add System.out.println to track exactly what values are coming into mouseScrolled events for troubleshooting
34. UI, mouse wheel scrolling, skip isMouseOver checks and directly forward scroll events to ensure they're captured in complex UI hierarchies
35. UI, utility methods, create dedicated rendering utilities for common UI drawing tasks to maintain consistent visuals and reduce code duplication
36. UI, popup management, handle popups in main screen render and mouse event methods, rendering them on top of all other content
37. UI, text input, override keyPressed and charTyped methods in screens to forward events to focused input components
38. UI, popup positioning, use full screen dimensions (not just UI panel dimensions) for correct screen-center popup placement
39. UI, absolute positioning, completely override the render method for components requiring exact screen positions rather than relying on parent-relative positioning
40. UI, layering, use matrix transformations (translate in Z direction) to ensure popups render on top of other UI elements
41. UI, control visibility, add specific System.out.println logging when controls aren't rendering to track their positions and states
42. UI, complex components, use direct rendering with immediate-mode approach rather than composing from other components when facing render order issues
43. UI, rendering utilities, create reusable static methods in utility classes for direct rendering to ensure consistent styling across all UI components
44. UI, grid management, recreate grids instead of clearing them when contents or layout need to change as many grid builders lack explicit reset methods
45. UI, modal windows, use fully opaque backgrounds (0xFF instead of 0xE0) and set position before creating child components to ensure proper layering
46. UI, event handlers, when updating common event methods (like mouseScrolled), preserve specialized handling for components that need direct event forwarding
47. UI, sizing strategy, size UI containers based on content requirements rather than fixed percentages of screen size to avoid excessive empty space
48. UI, debug logging, use conditional logging with LOGGER.isDebugEnabled() checks instead of direct System.out.println in frequently called methods
49. UI, adaptive sizing, calculate UI container dimensions based on actual content quantity with min/max constraints and recenter after resizing
50. UI, child positioning, when parent containers resize or reposition, manually update child component positions as they don't automatically inherit changes
51. UI, error handling, wrap callback execution in try-catch blocks to prevent errors in event handlers from breaking the entire UI
52. UI, constants, define layout constants as static final fields rather than hardcoding values throughout methods for better maintainability
53. UI, event system, use a copy of handler lists when iterating through event handlers to avoid concurrent modification exceptions
54. UI, defensive coding, add null checks for all data inputs and suppliers to prevent NullPointerExceptions in rendering code
55. UI, component resizing, trigger resize events after changing dimensions to ensure dependent components can react appropriately
56. UI, tooltips, render tooltips at the end of the rendering cycle to ensure they appear on top of all other UI elements
57. UI, key handling, handle vanilla Minecraft key bindings at both component and parent screen levels, always returning true to consume key events
58. UI, text input, prefer direct delegation to Minecraft's EditBox instead of custom cursor tracking to avoid cursor positioning bugs
59. UI, component wrappers, when facing issues with component behavior, try creating an ultra-minimal wrapper with almost no custom functionality
60. UI, text input components, when cursor is not visible, avoid custom drawing over or around Minecraft's EditBox and let it render itself completely
61. UI, edit input issues, when facing persistent cursor visibility problems, use vanilla EditBox directly without any custom component wrapper
62. UI, focus debugging, add detailed logging to track focus state changes and display warnings when focus operations fail
63. UI, input priority, when handling keyboard events, check focused components FIRST before handling any other keys
64. UI, text input components, for critical text editing functionality, directly use vanilla EditBox without any custom component wrapper
65. UI, EditBox rendering, always render EditBox directly in the render method immediately before or after child components, not as a child itself
66. UI, vanilla components, when using vanilla components like EditBox directly, ensure proper layout by adding the same labels and positioning logic
67. UI, EditBox styling, improve EditBox visibility by drawing a white border frame behind it and using high contrast text colors
68. UI, component rendering, when nested components don't position correctly, switch to direct rendering code that explicitly draws each element
69. UI, immediate mode UI, for complex interactive components like popups with EditBoxes, use direct rendering with minimal component hierarchy for reliability
70. UI, UIGridBuilder.java, when adding new UI element types, implement both direct (Item) and wrapped (ItemStack) versions of methods for flexibility
71. UI, TownInterfaceScreen.java, for interactive item displays, store quantities in a persistent array and use lambdas with final index variables for click handlers
72. UI, scrollable grid UI, calculate maxVisible dynamically based on container height and item height for responsive scrolling
73. UI, scrollbar implementation, use relative percentages to position scrollbar thumb based on content scroll position for accurate representation
74. UI, number formatting, implement suffix-based formatting (K, M, B) for large numbers to keep UI clean and readable
75. UI, item display alignment, use standard item size (16px) and vertically center items and text using font metrics for consistent appearance
76. UI, item quantity display, use Unicode symbols (×) instead of plain 'x' for better aesthetics and align quantities based on visual spacing
77. UI, text rendering, prefer ASCII characters over Unicode when text rendering issues occur with special characters
78. UI, mouse input, implement middle mouse button scrolling consistently across all scrollable components for a unified user experience
79. UI, scrollbar implementation, use identical scrollbar code and styling across different tabs/screens to maintain interface consistency
80. UI, event forwarding, ensure mouse and keyboard events are properly forwarded to all active components in tabbed interfaces, not just specific tabs
81. UI, debug logging, add detailed debug logs for input events to track event propagation and handling through the UI hierarchy
82. UI, code cleanup, remove temporary debug logging after confirming fixes to keep the codebase clean and maintainable