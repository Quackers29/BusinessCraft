# BusinessCraft - Cheat Sheet

## USAGE:
Prior to starting, check if there is the file 'CheatSheet.txt' in the root directory, read this file to remind you of past mistakes so you are less likely to make them again. At the end of every converstion when you are summerising what you have done, add to the root file 'CheatSheet.txt' one line per item (keep it space efficent, use example) of what you past you could have benefitted from knowing, specifically about resolving errors and what you needed to know not to make that error in the first place, dont just state everything youve done, be concise about useful error resolving tips, nothing specific to the task your were trying to accomplish.

## EXAMPLE (Not a real issue): 
1.  <Target> <path> <Method> <fix>
2.  UI, BCScreenBuiler.java, when creating a button, look out for missed references

#Remember ONE line per issue, no more.

# List of Lessons learned

1. UI, component rendering, use direct rendering at absolute positions for complex layouts and matrix transformations (pushPose/popPose) for nested components
2. UI, mouse events, always convert global mouse coordinates to panel-local coordinates and properly forward to child components
3. UI, component hierarchy, extend appropriate base classes and size panels to fit content rather than repositioning them
4. UI, color management, define color constants in one place and use semi-transparent colors (0xA0RRGGBB) for better UI contrast
5. UI, component factories, when adding methods to factory classes, ensure return types match expected usage and provide consistent pattern creation
6. UI, extending components, override necessary methods from parent class and disable default rendering with appropriate flags when implementing custom visuals
7. UI, layout strategy, use responsive layouts with grid-based systems and calculate dimensions based on container size rather than fixed values
8. UI, event handling, wrap callbacks in try-catch blocks and use adapter functions to bridge type differences between component event handlers
9. UI, state management, maintain persistent state variables for components that are recreated during rendering to preserve user interactions
10. UI, scrollable content, implement proper scrolling with consistent behavior across all components (including middle mouse button and wheel)
11. UI, utility methods, create dedicated rendering utilities for common UI patterns to ensure consistent styling and reduce code duplication
12. UI, popup and modal screens, handle layering properly with matrix transformations and render on top of other content with proper z-ordering
13. UI, text input components, use vanilla EditBox directly for critical text editing functionality to avoid cursor positioning and visibility issues
14. UI, item displays, standardize sizing (16px items) and formatting (Unicode symbols, K/M/B suffixes) for consistent inventory representations
15. UI, inventory screens, extend AbstractContainerScreen and implement AbstractContainerMenu for proper Minecraft item handling
16. UI, registry and screens, register all MenuTypes to the mod event bus and register MenuScreens in only one place to avoid duplicate registration errors
17. UI, navigation, include back/return buttons for all screens and explicitly handle parent-child relationships by passing parent references
18. Network, packet handling, use separate request/response packets for operations, add thorough validation, and implement static decode methods
19. UI, inventory slots, precisely align slot borders with actual inventory slot positions using consistent coordinate calculations
20. UI, AbstractContainerScreen, hide default labels, implement custom rendering, and maintain proper rendering order (background, slots, items, tooltips)
21. Data integration, implement flexible data access strategies with proper fallbacks and synchronization between client and server
22. BlockEntity, for client-side resource display, implement cache systems with proper getters and sync using level.sendBlockUpdated
23. UI, scrollbar implementation, create visual indicators for scroll position using relative percentages and consistent styling across all screens
24. UI, title rendering, use pose transformations for scaled text and position titles within content panels for integrated appearance
25. UI, screen sizing, scale dimensions based on content volume and reduce overlay size to avoid dominating gameplay area
26. UI, component templates, extract complex components into reusable classes with generic type parameters and builder pattern configuration
27. Network, packet handlers, check for all possible UI implementations when a packet can be handled by different screen types
28. UI, grid builder, provide appropriate column/row setup with consistent mouse event signatures and explicit sizing parameters
29. UI, modal inventory screens, render slots relative to modal panel coordinates and set player.containerMenu for proper item interaction
30. UI, UI transitions, control navigation flow with callbacks and ensure BlockPos is passed between related screens to maintain context
31. Storage systems, implement toggle mechanisms between different storage modes with clear visual indicators and state-preserving logic
32. Data structures, for player-specific data use nested maps (UUID -> Item -> Count) with proper fallback methods for empty collections
33. Network security, verify player identity in packets that modify player-specific data by comparing sender UUID to packet payload UUID
34. Client-side caching, implement cache update methods that clear and rebuild collections rather than modifying existing entries
35. UI state preservation, when toggling between modes, ensure cache updates only apply to the currently active mode to prevent UI flicker
36. UI, dynamic titles, use separate displayTitle field instead of Screen.title (which is final) when title needs to update based on state
37. Menu access, when creating helper methods like getTownBlockMenu(), ensure parameters match constructor and access block entities directly to get accurate data
38. UI initialization, always load mode-specific data both during screen initialization (init method) and when toggling between modes to ensure consistency
39. Client-server synchronization, when switching UI display modes, explicitly request fresh data from server via dedicated request packets rather than relying solely on client-side cache
40. Inventory interactions, prevent item duplication by checking for same-item interactions before processing custom inventory operations (e.g., ItemStack.isSameItemSameTags)
41. Item stacking, when implementing custom inventory stacking, track exact stack size changes (before/after) and send precise quantity changes to the server
42. Mouse button handling, in slotClicked overrides check both ClickType AND mouseButton to handle different operations (left-click vs right-click stack splitting)
43. UI, container initialization, player inventory slots are typically offset by main inventory size to ensure correct slot targeting.
44. UI, render logic, always call super.render() in render method overrides to ensure proper base rendering.
45. Inventory, data synchronization, always send packets to update storage after operations to maintain client-server sync.
46. Inventory, slot clicks, remember to maintain the server-side storage state for multiplayer consistency.
47. UI, screen implementation, override mouseClicked for click handling, render for display, and init for setup.
48. ItemStack handling, always copy() ItemStacks before modifying them to prevent unintended side effects.
49. Inventory, removal operations, track item state before/after operations to calculate actual changes.
50. Inventory, drag support, implement proper handling for QUICK_CRAFT operations by tracking drag stages (start:0, add:1, end:2).
51. Inventory, double-click collecting, handle PICKUP operations with null slot parameter to properly sync collected items.
52. Mouse drag operations, detect end of drag with mouseButton == 2 during QUICK_CRAFT operations to sync inventory afterwards.
53. Packet validation, when implementing special case packet handling (like refresh requests), ensure validation checks don't reject the special case before it's processed.
54. Variable scope, declare variables at the beginning of methods and avoid redeclaring them in nested blocks to prevent duplicate variable errors.
55. UI, drag operations, must handle both left-click (mouseButton 0,1,2) and right-click (mouseButton 4,5,6) drag types in QUICK_CRAFT to properly track all affected slots.
56. UI, inventory interactions, support all click types including single right-click with non-empty carried item (PICKUP, mouseButton=1, !carried.isEmpty()) to place one item.
57. UI, inventory swapping, when placing one item on a different item (swapping), need to properly remove old item and add new item to prevent duplication.
58. UI, shift-clicking, handle ClickType.QUICK_MOVE separately from other clicks to properly track items moved between inventories and prevent duplication.
59. UI, shift-clicking to storage, capture all storage slot states before operation then identify which slots received items to properly add to server.
60. When debugging inventory operations, keep only essential logs (errors, warnings, and critical state changes) and remove verbose debugging once the issue is resolved
61. Track affected slots to prevent duplicate updates during shift-click operations
62. When handling item stack updates, check both item type and count to determine if an update is necessary
63. Avoid removing and adding entire stacks when counts remain unchanged
64. Always send server updates for all inventory changes, regardless of client-side visual updates
65. UI, font rendering, always use Minecraft.getInstance().font for text rendering in GuiGraphics.drawString() calls to ensure consistent font access
66. UI, screen replacement, when replacing a screen with a newer version, update MenuScreens registration and handle any interface references (like menu.getTownBlockMenu()) in dependent classes
67. UI, screen registration, avoid duplicate MenuScreens.register() calls for the same menu type across different classes (like BusinessCraft.java and ClientModEvents.java)
68. UI, code deletion, when removing a UI component, check for base classes and utility methods that are only used by that component to avoid leftover unused code
69. UI, import management, regularly clean up imports and remove duplicates to avoid compilation issues and improve code readability (TownInterfaceMenu had 500+ duplicated imports)
70. Project structure, avoid duplicate directories for the same functionality (like network/ and networking/) to prevent code fragmentation and maintenance issues
71. Package deprecation, mark obsolete classes with @Deprecated and provide Javadoc references to the preferred alternatives to guide future developers
72. Unused variable cleanup, regularly check for and remove unused variables in example/demo classes to improve readability and prevent confusion
73. Project maintainability, create README files in obsolete directories to document migration paths and preferred alternatives
74. UI, mouse dragging, implement common behavior in base components and adjust for local coordinates, ensuring all scrollable areas follow consistent event pattern
75. UI, state management, implement time-to-live caching to reduce direct entity/provider access and improve UI responsiveness, with graceful fallbacks
76. Notification systems, use visit buffers to group notifications by origin instead of sending individual messages, triggering grouped notifications when processing the buffer
77. Reward systems, calculate payments based on travel distance and process rewards at the visit buffer level to correctly associate grouped tourists with their collective rewards