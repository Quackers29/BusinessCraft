# BusinessCraft UI Component System

## IMPORTANT: Tab Panel Implementation Notes

When implementing tabbed interfaces using BCTabPanel, keep these crucial points in mind:

1. **Rendering Order:** The tab panel renders elements in this specific order:
   - First: The container background
   - Second: The content of the active tab
   - Third: The tab buttons on top
   This ordering ensures proper layering of visual elements.

2. **Proper Tab Content Positioning:** 
   - Content panels MUST be positioned relative to the content area of the tab panel
   - Default position is (0,0) within the content area (which is offset from the tab panel's origin)
   - When switching tabs, proper repositioning of the new tab's content is essential

3. **Mouse Event Handling:** 
   - Mouse events are properly translated to panel-local coordinates
   - Clicks outside of tab content don't affect the inactive tabs
   - For mouse wheel scrolling, use direct event forwarding without position checks in complex hierarchies

4. **Common Issues and Solutions:**
   - Blank tabs often result from incorrect positioning - ensure tab content is positioned properly
   - Missing content can be caused by incorrect panel visibility states
   - Always check both position and visibility when debugging tab issues
   - For rendering hierarchies, use matrix transformations (pushPose/popPose) for proper coordinate spaces

5. **New Tab Panel Implementation:**
   - The redesigned BCTabPanel extends BCComponent directly for better control
   - Tab rendering is done directly rather than through child components
   - Matrix transformations are used for proper coordinate handling
   - Only the active tab content is rendered to avoid visibility conflicts
   - Mouse events are properly translated before forwarding to child components

## Advanced UI Features

### UIGridBuilder

UIGridBuilder is a flexible utility for creating grid-based layouts:

```java
// Create a grid with specific columns and sizing
UIGridBuilder grid = new UIGridBuilder(width, height)
    .withColumns(3, 1, 1)  // 3 columns with relative widths 3:1:1
    .withPadding(5)        // 5px padding around cells
    .withSpacing(8);       // 8px spacing between cells

// Add content to the grid
grid.add("Label:", 0, 0);  // Add at column 0, row 0
grid.add(valueLabel, 1, 0, 2);  // Span across 2 columns

// Render the grid
grid.render(guiGraphics, mouseX, mouseY);
```

Key features:
- Flexible column configuration with relative widths
- Row and column spanning for complex layouts
- Automatic row creation as content is added
- Support for mixed component types (strings, Components, UI components)
- Automatic text styling with highlight options
- Border and background rendering

### Scrollable Content

Implement scrollable content areas with these best practices:

```java
// In your component class
private int scrollOffset = 0;
private int maxVisible;  // Calculate based on available height
private final int itemHeight = 16;

@Override
public boolean mouseScrolled(double mouseX, double mouseY, double delta) {
    // Calculate max scroll offset
    int maxScrollOffset = Math.max(0, totalItems - maxVisible);
    
    // Apply scrolling directly based on delta sign
    scrollOffset -= (int)Math.signum(delta);
    
    // Clamp scroll position
    scrollOffset = Math.max(0, Math.min(scrollOffset, maxScrollOffset));
    
    return true;
}

// When rendering content
private void renderItems(GuiGraphics graphics, int mouseX, int mouseY) {
    for (int i = scrollOffset; i < Math.min(totalItems, scrollOffset + maxVisible); i++) {
        int y = verticalPadding + (i - scrollOffset) * itemHeight;
        // Render item at position y
    }
    
    // Optionally render scrollbar
    renderScrollbar(graphics, mouseX, mouseY);
}
```

Tips for effective scrolling:
- Skip isMouseOver checks when forwarding wheel events in complex hierarchies
- Calculate maxVisible dynamically based on container dimensions
- Implement multiple scroll methods (wheel, middle-mouse drag, scrollbar)
- Use Math.signum(delta) for consistent scrolling speed across platforms

### Animation Framework

Create smooth UI transitions with the animation system:

```java
// Fade in animation
private float alpha = 0.0f;
private long startTime;
private boolean animationStarted = false;

// In your render method
if (!animationStarted) {
    startTime = Minecraft.getInstance().level.getGameTime();
    animationStarted = true;
}

// Calculate animation progress
long currentTime = Minecraft.getInstance().level.getGameTime();
long elapsed = currentTime - startTime;
if (elapsed > 10) {  // Delay start by 10 ticks
    alpha = Math.min(1.0f, (elapsed - 10) / 20.0f);  // Fade in over 20 ticks
}

// Apply animation
graphics.pose().pushPose();
graphics.pose().mulPose(Vector3f.ZP.rotationDegrees(0));
RenderSystem.enableBlend();
RenderSystem.setShaderColor(1.0F, 1.0F, 1.0F, alpha);
// Render content
RenderSystem.setShaderColor(1.0F, 1.0F, 1.0F, 1.0F);
RenderSystem.disableBlend();
graphics.pose().popPose();
```

Animation best practices:
- Use game time rather than system time for consistent animation speed
- Apply sequenced animations with staggered delays for a cascading effect
- Always restore render state after animations (alpha, blend mode, etc.)
- Use matrix transformations for complex animations

### Pattern Consistency

For a professional UI experience, apply these consistent patterns:

1. **Tab Layout Patterns:**
   - Overview tabs: Use 2-column grid with labels in column 1 and values in column 2
   - List tabs: Use consistent item height and padding with scrollable content
   - Settings tabs: Organize controls in logical groups with headers

2. **Color Usage:**
   - Use TEXT_COLOR for regular text
   - Use TEXT_HIGHLIGHT for emphasis and important values
   - Use consistent background and border colors throughout
   - Apply semi-transparent colors (0xA0RRGGBB) for better UI depth

3. **Interactive Elements:**
   - Provide clear visual feedback for hover/click states
   - Use consistent button sizing and grouping
   - Place navigation controls in predictable locations

## Quick Reference Guide

This manual provides a brief overview of the BusinessCraft UI component system, designed for creating interactive interfaces in Minecraft mods.

### Core Components

**BCComponent.java**
Base component class that all UI elements inherit from. Provides common functionality like positioning, sizing, visibility, rendering, animations, and event handling.

**BCPanel.java**
Container component that holds and arranges other components. Can use different layout managers to organize child components. Supports features like padding, background colors, borders, and rounded corners.

**BCTabPanel.java**
Specialized panel that implements a tabbed interface. Manages tab buttons and content panels, allowing only one tab to be visible at a time. Proper positioning of tab content is crucial.

**BCLabel.java**
Text display component with configurable styles, colors, and alignment options. Supports static and dynamic text content through suppliers.

**BCButton.java**
Interactive button component that can trigger actions when clicked. Supports different button styles, states, hover effects, and can include icons.

**BCComponentFactory.java**
Factory class with helper methods to create standardized UI components with consistent styling.

**BCTheme.java**
Defines standard colors, sizes, and styles used throughout the UI system for a consistent appearance.

### Layout Managers

**BCLayout.java**
Base interface for all layout managers.

**BCFlowLayout.java**
Arranges components in a directional flow (horizontal or vertical) with configurable spacing.

**BCGridLayout.java**
Arranges components in a grid pattern with configurable columns, row height, and spacing.

### Data Components

**BCEditBoxComponent.java**
Text input component for user-editable text fields. Supports validation, styling, and focus states.

**BCToggleButton.java**
Button that toggles between two states (on/off) with visual feedback.

**BCDynamicLabel.java**
Label with dynamic content that updates based on a supplier function.

### Common Pitfalls and Solutions

1. **Tab Panel Positioning**
   When switching tabs, ensure tab content panels are correctly positioned. The BCTabPanel positions content panels relative to itself.

2. **Component Visibility**
   Always manage component visibility states correctly. Components won't render if their visible property is false.

3. **Mouse Interaction**
   Properly convert global mouse coordinates to local coordinates when handling mouse events in nested components.

4. **Animation Usage**
   Use animations sparingly for non-critical UI elements. Keep them simple and brief for best performance.

5. **Event Handling**
   Set up event handlers properly and avoid circular dependencies in event chains.

### Usage Guide

1. **Creating a Basic Screen:**
   ```java
   // Create a panel to hold components
   BCPanel panel = new BCPanel(width, height);
   
   // Add components to the panel
   panel.addChild(BCComponentFactory.createHeaderLabel("Title", width));
   panel.addChild(BCComponentFactory.createBodyLabel("Content", width));
   
   // Set a layout
   panel.withLayout(new BCFlowLayout(BCFlowLayout.Direction.VERTICAL, 5));
   ```

2. **Creating a Tabbed Interface:**
   ```java
   // Create a tab panel
   BCTabPanel tabPanel = new BCTabPanel(width, height, 20);
   
   // Create content panels for each tab
   BCPanel tab1Content = new BCPanel(width, height - 20);
   // Add components to tab1Content...
   
   // Add tabs
   tabPanel.addTab("tab1", Component.literal("Tab 1"), tab1Content);
   // Add more tabs...
   
   // Initialize the tab panel
   tabPanel.init(this::addRenderableWidget);
   ```

3. **Component Styling:**
   ```java
   // Create a label with custom styling
   BCLabel label = BCComponentFactory.createBodyLabel("Text", 100);
   label.withTextColor(0xFFFFFF);
   label.withShadow(true);
   ```

4. **Dynamic Content:**
   ```java
   // Create a dynamic label that updates when data changes
   BCLabel dynamicLabel = BCComponentFactory.createDynamicLabel(
       () -> Component.literal("Value: " + getValue()),
       200
   );
   ```

5. **Handling User Input:**
   ```java
   // Create a button with an action
   BCButton button = BCComponentFactory.createPrimaryButton(
       "Click Me",
       button -> performAction(),
       100
   );
   ```

6. **Using Animation:**
   ```java
   // Animate a component to fade in
   component.withAlpha(0.0f);
   component.animate("alpha", 1.0f, 500); // 500ms fade-in
   ```

### Implementation Tips

- Use `BCScreenBuilder` for quick creation of standard screens
- Always initialize components with `init()` method before rendering
- Use `position()` to place components relative to their parent
- Remember to call `layoutChildren()` if using layout managers
- For custom screens, override the `render()` method to draw components
- Ensure tab panels correctly position their content panels
- Check components are being rendered within their parent's bounds 